/******************************************************************************
* Copyright (c) 2011, Howard Butler, hobu.inc@gmail.com
*
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following
* conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in
*       the documentation and/or other materials provided
*       with the distribution.
*     * Neither the name of Hobu, Inc. or Flaxen Geo Consulting nor the
*       names of its contributors may be used to endorse or promote
*       products derived from this software without specific prior
*       written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
* OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
* AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
* OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
* OF SUCH DAMAGE.
****************************************************************************/

#include <pdal/drivers/pgpointcloud/Reader.hpp>
#include <pdal/PointBuffer.hpp>
#include <pdal/FileUtils.hpp>
#include <pdal/Utils.hpp>
#include <pdal/StageFactory.hpp>

#include <boost/shared_ptr.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/tokenizer.hpp>
#include <boost/make_shared.hpp>
#include <boost/algorithm/string.hpp>

#include <iostream>
#include <map>



#ifdef USE_PDAL_PLUGIN_PGPOINTCLOUD
MAKE_READER_CREATOR(pgpointcloudReader, pdal::drivers::pgpointcloud::Reader)
CREATE_READER_PLUGIN(pgpointcloud, pdal::drivers::pgpointcloud::Reader)
#endif


namespace pdal
{
namespace drivers
{
namespace pgpointcloud
{


Reader::Reader(const Options& options)
    : pdal::Reader(options)
    , m_session(0)
    , m_connection("")
    , m_table_name("")
    , m_schema_name("")
    , m_column_name("")
    , m_where("")
    , m_pcid(0)
    , m_cached_point_count(0)
    , m_cached_patch_count(0)
    , m_cached_max_points(0)
{

}

Options Reader::getDefaultOptions()
{
    Options options;

    Option connection("connection", "", "Connection string to connect to database");
    Option table("table", "", "Table to read out of");
    Option schema("schema", "", "Schema to read out of");
    Option column("column", "", "Column to read out of");
    Option where("where", "", "SQL where clause to filter query");
    Option spatialreference("spatialreference", "", "override the source data spatialreference")

    options.add(connection);
    options.add(table);
    options.add(schema);
    options.add(column);
    options.add(where);
    options.add(spatialreference);

    return options;
}

Reader::~Reader()
{
    return;
}


void Reader::initialize()
{
    pdal::Reader::initialize();

    // If we don't know the table name, we're SOL
    m_table_name = getOptions().getValueOrThrow<std::string>("table");

    // Schema and column name can be defaulted safely
    m_column_name = getOptions().getValueOrDefault<std::string>("column", "pa");
    m_schema_name = getOptions().getValueOrDefault<std::string>("schema", "");

    // Connection string needs to exist and actually work
    std::string connection = getOptions().getValueOrThrow<std::string>("connection");

    // No string, nothing we can do
    if ( ! connection.size() )
    {
        throw soci_driver_error("unable to connect to database, no connection string was given!");
    }

    // Can we connect, using this string?
    try
    {
        m_session = new ::soci::session(::soci::postgresql, connection);
        log()->get(logDEBUG) << "Connected to database" << std::endl;
    } 
    catch (::soci::soci_error const &e)
    {
        std::stringstream oss;
        oss << "Unable to connect '" << connection << "' with error '" << e.what() << "'";
        throw pdal_error(oss.str());
    }

    // Direct database log info to the logger
    m_session->set_log_stream(&(log()->get(logDEBUG2)));

    // Read other preferences
    m_where = getOptions().getValueOrDefault<std::string>("where", "");
 
    // Read schema from pointcloud_formats if possible
    Schema& schema = getSchemaRef();
    schema = fetchSchema();

    // Allow spatialreference override if desired
    try
    {
        setSpatialReference(getOptions().getValueOrThrow<pdal::SpatialReference>("spatialreference"));
    }
    catch (pdal::option_not_found const&)
    {
        // Read from pointcloud_formats otherwise
        setSpatialReference(fetchSpatialReference());
    }

}

boost::uint64_t Reader::getNumPoints() const
{
    if ( m_cached_point_count == 0 )
    {
        std::ostringstream oss;
        oss << "SELECT Sum(PC_NumPoints(" << m_column_name << ")) AS numpoints, ";
        oss << "Count(*) AS numpatches ";
        oss << "Max(PC_NumPoints(" << m_column_name << ")) AS maxpoints FROM ";
        if ( m_schema_name.size() )
        {
            oss << m_schema_name << ".";
        }
        oss << m_table_name;
        if ( m_where.size() )
        {
            oss << " " << m_where;
        }

        m_session->once << oss.str(), ::soci::into(m_cached_point_count), ::soci::into(m_cached_patch_count), ::soci::into(m_cached_max_points);
        oss.str("");
    }

    return m_cached_point_count;
}

boost::uint64_t Reader::getNumPatches() const
{
    if ( m_cached_point_count == 0 )
    {
        boost::uint64_t npoints = getNumPoints();
    }
    return m_cached_patch_count;
}

boost::uint64_t Reader::getMaxPoints() const
{
    if ( m_cached_point_count == 0 )
    {
        boost::uint64_t npoints = getNumPoints();
    }
    return m_cached_max_points;
}


boost::uint32_t Reader::fetchPcid()
{
    boost::uint32_t pcid = 0;

    if ( m_pcid ) return m_pcid;

    std::ostringstream oss;
    oss << "SELECT PC_Typmod_Pcid(a.atttypmod) AS pcid ";
    oss << "FROM pg_class c, pg_attribute a ";
    oss << "WHERE c.relname = '" << m_table_name << "' ";
    oss << "AND a.attname = '" << m_column_name << "' ";

    m_session->once << oss.str(), ::soci::into(pcid);
    oss.str("");

    if ( ! pcid )
        throw pdal_error("Unable to fetch pcid specified column and table");
    
    return pcid;
}

pdal::Schema Reader::fetchSchema() const
{
    log()->get(logDEBUG) << "Fetching schema object" << std::endl;

    boost::uint32_t pcid = fetchPcid();

    std::ostringstream oss;
    oss << "SELECT schema FROM pointcloud_formats WHERE pcid = " << pcid;

    ::soci::row r;
    ::soci::statement schemas = (m_session->prepare << oss.str(), ::soci::into(r));
    schemas.execute();
        
    if ( ! schemas.fetch() )
        throw pdal_error("Unable to retreive schema XML for specified column and table");

    std::string xml = r.get<std::string>("schema");    

    Schema schema = Schema::from_xml(xml);

    schema::index_by_index const& dims = schema.getDimensions().get<schema::index>();

    for (schema::index_by_index::const_iterator iter = dims.begin(); iter != dims.end(); ++iter)
    {
        // For dimensions that do not have namespaces, we'll set the namespace 
        // to the namespace of the current stage
        
        if (iter->getNamespace().size() == 0)
        {
            log()->get(logDEBUG4) << "setting namespace for dimension " << iter->getName() << " to "  << getName() << std::endl;
            

            Dimension d(*iter);
            if (iter->getUUID().is_nil())
            {
                d.createUUID();
            }            
            d.setNamespace(getName());
            schema.setDimension(d);        
        }
    }

    return schema;
}

pdal::SpatialReference Reader::fetchSpatialReference() const
{
    // Fetch the WKT for the SRID to set the coordinate system of this stage
    log()->get(logDEBUG) << "Fetching spatial setSpatialReference object" << std::endl;

    boost::uint32_t pcid = fetchPcid();

    // query_oss << "select ST_SRID(query.extent)::integer as code from (" << query << ") as query";
    // query_oss << "SELECT ST_SRID(extent)::integer as code from cloud";

    std::ostringstream oss;
    oss << "SELECT srid FROM pointcloud_formats WHERE pcid = " << pcid;

    ::soci::row r;
    ::soci::indicator ind;
    ::soci::statement srids = (m_session->prepare << oss.str(), ::soci::into(r, ind));
    srids.execute();
    oss.str("");
    
    if ( ! srids.fetch() )
        throw pdal_error("Unable to fetch srid for this table and column");
    
    boost::int32_t srid = r.get<boost::int32_t>("srid");

    if (ind == ::soci::i_null)
    {
        log()->get(logDEBUG) << "No SRID was selected for query" << std::endl;
        return pdal::SpatialReference();
    }

    log()->get(logDEBUG) << "query returned " << srid << std::endl;    

    oss << "EPSG:" << srid;

    if ( srid >= 0 )
        return pdal::SpatialReference(oss.str());
    else
        return pdal::SpatialReference();
}


pdal::StageSequentialIterator* Reader::createSequentialIterator(PointBuffer& buffer) const
{
    return new pdal::drivers::pgpointcloud::iterators::sequential::Reader(*this, buffer);
}

namespace iterators
{
namespace sequential
{


IteratorBase::IteratorBase(const pdal::drivers::pgpointcloud::Reader& reader)
    : m_at_end(false)
    , m_active_buffer(BufferPtr())
    , m_buffer_position(0)
    , m_reader(reader)
{
    pdal::Options const& options = reader.getOptions();
    std::string const& connection = options.getValueOrThrow<std::string>("connection");
    std::string const& query = options.getValueOrThrow<std::string>("query");
        
    m_database_type = getReader().getDatabaseType();
    m_session = connectToDataBase(connection, m_database_type);
    
    return;
}

::soci::statement IteratorBase::getNextCloud(   std::string const& cloud_table_name, 
                                                boost::int32_t& cloud_id, 
                                                ::soci::row& r)
{

    std::ostringstream select_blocks;

    select_blocks
            << "select T.cloud_id, T.block_id, T.extent::box3d::text, T.num_points, T.points from "
            << cloud_table_name << " T WHERE T.cloud_id = "
            << cloud_id;

    ::soci::statement blocks = (m_session->prepare << select_blocks.str(), ::soci::into(r));
    blocks.execute();
    return blocks;

}

IteratorBase::~IteratorBase()
{
}



const pdal::drivers::pgpointcloud::Reader& IteratorBase::getReader() const
{
    return m_reader;
}

void IteratorBase::readBlob(::soci::row& block,
                            boost::uint32_t howMany)
{
    boost::uint32_t nAmountRead = 0;
    
    std::stringstream hex_data;
    hex_data << block.get<std::string>("points");
    
    std::size_t trim = 2;
    std::string trimmed = hex_data.str().substr(trim, hex_data.str().size()-trim);
    std::vector<boost::uint8_t> binary_data = Utils::hex_string_to_binary(trimmed);
    
    
    unsigned char* data = (unsigned char*) &(binary_data.front());

    Schema const& oracle_schema = m_active_buffer->getSchema();

    boost::uint32_t howMuchWeRead = binary_data.size();
    boost::uint32_t howMuchTheBlobShouldBe = block.get<int>("num_points") * oracle_schema.getByteSize();
    if (howMuchWeRead != howMuchTheBlobShouldBe)
    {
        std::stringstream oss;
        oss << "Did not read the amount of binary data as expected -- read: " << howMuchWeRead << " should read: " << howMuchTheBlobShouldBe;
        throw soci_driver_error(oss.str());
    }
    boost::uint32_t howMuchToRead = howMany * oracle_schema.getByteSize();
    m_active_buffer->setDataStride(data, 0, howMuchToRead);

    m_active_buffer->setNumPoints(howMany);    
}

void IteratorBase::fillUserBuffer(PointBuffer& user_buffer)
{

    Schema const& user_schema = user_buffer.getSchema();
    schema::index_by_index const& idx = user_schema.getDimensions().get<schema::index>();

    boost::int32_t numUserSpace = user_buffer.getCapacity() - user_buffer.getNumPoints();
    if (numUserSpace < 0)
        throw pdal_error("We ran out of space!");

    boost::int32_t numOraclePoints = m_active_buffer->getNumPoints() - m_buffer_position;
    
    schema::index_by_index::size_type i(0);
    for (i = 0; i < idx.size(); ++i)
    {
            copyDatabaseData( *m_active_buffer, 
                            user_buffer, 
                            idx[i], 
                            m_buffer_position, 
                            user_buffer.getNumPoints(), 
                            (std::min)(numOraclePoints,numUserSpace));

    }

    bool bSetPointSourceId = getReader().getOptions().getValueOrDefault<bool>("populate_pointsourceid", false);
    if (bSetPointSourceId)
    {  
        Dimension const* point_source_field = &(user_buffer.getSchema().getDimensionOptional("PointSourceId").get());
        if (point_source_field)
        {  
            for (boost::int32_t i = 0; i < numUserSpace; ++i)
            {  
                if (i < 0)
                    throw soci_driver_error("point_source_field point index is less than 0!");
                user_buffer.setField(*point_source_field, i, m_active_cloud_id);
            }
        }
    }
        
    if (numOraclePoints > numUserSpace)
        m_buffer_position = m_buffer_position + numUserSpace;
    else if (numOraclePoints < numUserSpace)
        m_buffer_position = 0;
    
    boost::uint32_t howManyThisRead = (std::min)(numUserSpace, numOraclePoints);
    user_buffer.setNumPoints(howManyThisRead + user_buffer.getNumPoints());
}

void IteratorBase::copyDatabaseData(  PointBuffer& source, 
                                      PointBuffer& destination, 
                                      Dimension const& dest_dim, 
                                      boost::uint32_t source_starting_position, 
                                      boost::uint32_t destination_starting_position,
                                      boost::uint32_t howMany)
{
    
    boost::optional<Dimension const&> source_dim = source.getSchema().getDimensionOptional(dest_dim.getName());
    
    if (!source_dim)
    {
        return;
    }

    for (boost::uint32_t i = 0; i < howMany; ++i)
    {
        if (dest_dim.getInterpretation() == source_dim->getInterpretation() &&
            dest_dim.getByteSize() == source_dim->getByteSize() && 
            pdal::Utils::compare_distance(dest_dim.getNumericScale(), source_dim->getNumericScale()) &&
            pdal::Utils::compare_distance(dest_dim.getNumericOffset(), source_dim->getNumericOffset()) &&
            dest_dim.getEndianness() == source_dim->getEndianness() 
            )
        {
            // FIXME: This test could produce false positives
            boost::uint8_t* source_position = source.getData(source_starting_position+i) + source_dim->getByteOffset();
            boost::uint8_t* destination_position = destination.getData(destination_starting_position + i) + dest_dim.getByteOffset();
            memcpy(destination_position, source_position, source_dim->getByteSize());
        }
        else
        {
            PointBuffer::scaleData( source, 
                                    destination, 
                                    *source_dim, 
                                    dest_dim, 
                                    source_starting_position + i,
                                    destination_starting_position + i);
        }
    }
    
}

boost::uint32_t IteratorBase::myReadBuffer(PointBuffer& data)
{
        std::cout << "we have: " << data.getNumPoints() <<  " for capcity: " << data.getCapacity() << std::endl;
    if (getReader().getQueryType() == QUERY_CLOUD)
        return myReadClouds(data);
    if (getReader().getQueryType() == QUERY_BLOCKS_PLUS_CLOUD_VIEW)
    {
        std::string const& query = getReader().getOptions().getValueOrThrow<std::string>("query");
        ::soci::statement blocks = m_session->prepare << query;
        ::soci::row block;

        return myReadBlocks(data, blocks, block);
    }

    return 0;
}

boost::uint32_t IteratorBase::myReadClouds(PointBuffer& user_buffer)
{
    boost::uint32_t numRead(0);


    ::soci::row cloud;
    std::string query = getReader().getOptions().getValueOrThrow<std::string>("query");
    ::soci::statement clouds = (m_session->prepare << query, ::soci::into(cloud));
    clouds.execute();
    bool bReadCloud = clouds.fetch();
    
    if (bReadCloud)
        getReader().log()->get(logDEBUG2) << "Fetched buffer with cloud id: " << cloud.get<int>("cloud_id") << " for myReadClouds" << std::endl;
    else
        getReader().log()->get(logDEBUG) << "unable to fetch initial cloud!" << std::endl;
        
    while (bReadCloud)
    {
        
        // std::string blocks_query = fetchBlocks(cloud);
        std::string blocks_query("SELECT SOMETHING");
        std::string const& block_table = cloud.get<std::string>("block_table");
        boost::int32_t cloud_id = cloud.get<int>("cloud_id");
        std::string const& schema = cloud.get<std::string>("schema");
        m_active_buffer = fetchPointBuffer(cloud_id, schema);

        ::soci::row block;
        ::soci::statement blocks = getNextCloud(block_table, cloud_id, block);
        boost::uint32_t numReadThisCloud = myReadBlocks(user_buffer, blocks, block);
        numRead = numRead + numReadThisCloud;

        getReader().log()->get(logDEBUG2) << "Read " << numReadThisCloud << " points from myReadBlocks" << std::endl;
        
        bReadCloud = clouds.fetch();
        if (!bReadCloud && numReadThisCloud == 0)
        {
            m_at_end = true;
            break;
        }
    }

    return numRead;
}

BufferPtr IteratorBase::fetchPointBuffer(   boost::int32_t const& cloud_id,
                                            std::string const& schema_xml)
{
    BufferMap::const_iterator i = m_buffers.find(cloud_id);

    if (i != m_buffers.end())
    {
        getReader().log()->get(logDEBUG2) << "IteratorBase::fetchPointBuffer: found existing PointBuffer with id " << cloud_id << std::endl;
        return i->second;
    }
    else
    {
        std::stringstream query;

        Schema schema = Schema::from_xml(schema_xml);

        BufferPtr output  = BufferPtr(new PointBuffer(schema));
        std::pair<int, BufferPtr> p(cloud_id, output);
        m_buffers.insert(p);
        getReader().log()->get(logDEBUG2) << "IteratorBase::fetchPointBuffer: creating new PointBuffer with id " << cloud_id << std::endl;

        return p.second;
    }
}

boost::uint32_t IteratorBase::myReadBlocks(PointBuffer& user_buffer, ::soci::statement& blocks, ::soci::row& block)
{
    boost::uint32_t numPointsRead = 0;
    
    // user_buffer.setNumPoints(0);

    if (!m_active_buffer) 
    {
        m_active_buffer = fetchPointBuffer(block.get<int>("cloud_id"), block.get<std::string>("schema"));
        m_active_cloud_id = block.get<int>("cloud_id");
    }
    // 
    // This shouldn't ever happen
    int num_points = block.get<int>("num_points");
    if (num_points > static_cast<boost::int32_t>(m_active_buffer->getCapacity()))
    {
        std::ostringstream oss;
        oss << "Block size, " << num_points <<", is too large to fit in "
            << "buffer of size " << user_buffer.getCapacity() <<". Increase buffer capacity with writer's \"chunk_size\" option "
            << "or increase the read buffer size";
        throw buffer_too_small(oss.str());
    }
    // 
    // if (!m_block->num_points)
    // {
    //     // We still have a block of data from the last readBuffer call
    //     // that was partially read.
    //     getReader().log()->get(logDEBUG3) << "IteratorBase::myReadBlocks: fetching first block" << std::endl;
    //     bDidRead = m_initialQueryStatement->Fetch();
    //     if (!bDidRead)
    //     {
    //         m_at_end = true;
    //         return 0;
    //     }
    // 
    //     user_buffer.setSpatialBounds(getBounds(m_initialQueryStatement, m_block));
    // 
    // }
    // else
    // {
    //     // Our read was already "done" last readBuffer call, but if we're done,
    //     // we're done
    //     if (m_at_end)
    //         getReader().log()->get(logDEBUG3) << "IteratorBase::myReadBlocks: we are at end of the blocks;" << std::endl;
    //     else
    //         getReader().log()->get(logDEBUG3) << "IteratorBase::myReadBlocks: we have points left to read on this block" << std::endl;
    // 
    //     if (m_at_end) return 0;
    //     bDidRead = true;
    // 
    // }
    // 
    
    bool bDidRead = blocks.fetch();
    while (bDidRead)
    {
        boost::uint32_t numReadThisBlock = static_cast<boost::uint32_t>(block.get<int>("num_points"));
        boost::uint32_t numSpaceLeftThisBuffer = user_buffer.getCapacity() - user_buffer.getNumPoints();
    
        getReader().log()->get(logDEBUG4) << "IteratorBase::myReadBlocks:" "numReadThisBlock: "
                                          << numReadThisBlock << " numSpaceLeftThisBlock: "
                                          << numSpaceLeftThisBuffer << " total numPointsRead: "
                                          << numPointsRead << std::endl;
    
        numPointsRead = numPointsRead + numReadThisBlock;
    
        readBlob(block, numSpaceLeftThisBuffer);
        fillUserBuffer(user_buffer);
        // if (m_buffer_position != 0)
        // {
        //     return user_buffer.getNumPoints();
        // } 
        // else
        // {
        //     bDidRead = m_initialQueryStatement->Fetch();
        //     if (!bDidRead)
        //     {
        //         getReader().log()->get(logDEBUG3) << "IteratorBase::myReadBlocks: done reading block. Read " << numPointsRead << " points" << std::endl;
        //         // m_at_end = true;
        //         return user_buffer.getNumPoints();
        //     }
        // }
        
        bDidRead = blocks.fetch();
        if (!bDidRead)
            return user_buffer.getNumPoints();
    
        if (getReader().getQueryType() == QUERY_BLOCKS_PLUS_CLOUD_VIEW)
        {
            boost::int32_t const& current_cloud_id = block.get<int>("cloud_id");
            if (current_cloud_id != m_active_cloud_id)
            {
                

                getReader().log()->get(logDEBUG3) << "IteratorBase::myReadBlocks: current_cloud_id: "
                                                  << current_cloud_id << " m_active_cloud_id: "
                                                  << m_active_cloud_id << std::endl;                
                std::string schema;
                m_active_buffer = fetchPointBuffer(current_cloud_id, schema);
    
                m_active_cloud_id = current_cloud_id;
                return user_buffer.getNumPoints();
            }
        }
    }


    return numPointsRead;
}
// 
// pdal::Bounds<double> IteratorBase::getBounds(Statement statement, BlockPtr block)
// {
//     pdal::Vector<double> mins;
//     pdal::Vector<double> maxs;
// 
//     boost::int32_t bounds_length = statement->GetArrayLength(&(block->blk_extent->sdo_ordinates));
// 
//     getReader().log()->get(logDEBUG3) << "IteratorBase::getBounds: bounds length " << bounds_length << std::endl;
// 
//     double x(0.0);
//     double y(0.0);
// 
//     statement->GetElement(&(block->blk_extent->sdo_ordinates), 0, &x);
//     mins.add(x);
//     statement->GetElement(&(block->blk_extent->sdo_ordinates), 1, &y);
//     mins.add(y);
//     statement->GetElement(&(block->blk_extent->sdo_ordinates), 2, &x);
//     maxs.add(x);
//     statement->GetElement(&(block->blk_extent->sdo_ordinates), 3, &y);
//     maxs.add(y);
// 
//     pdal::Bounds<double> block_bounds(mins, maxs);
// 
//     getReader().log()->get(logDEBUG2) << "IteratorBase::getBounds: Fetched bounds of " << block_bounds << std::endl;
//     return block_bounds;
// }



//---------------------------------------------------------------------------
//
// SequentialIterator
//
//---------------------------------------------------------------------------

Reader::Reader(const pdal::drivers::pgpointcloud::Reader& reader, PointBuffer& buffer)
    : IteratorBase(reader)
    , pdal::StageSequentialIterator(reader, buffer)
{
    return;
}


Reader::~Reader()
{
    return;
}


boost::uint64_t Reader::skipImpl(boost::uint64_t count)
{

    return naiveSkipImpl(count);
}


bool Reader::atEndImpl() const
{
    // return true;
    return m_at_end;
}


boost::uint32_t Reader::readBufferImpl(PointBuffer& data)
{
    // return data.getNumPoints();
    return myReadBuffer(data);
}



}
} // iterators::sequential::

}
}
} // namespace pdal::driver::pgpointcloud
