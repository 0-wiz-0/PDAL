.. _normalized_heights:

==============================
Calculating Normalized Heights
==============================

:Author: Bradley Chambers
:Contact: brad.chambers@gmail.com
:Date: 11/11/2015

This tutorial will describe the process of computing Normalized Heights using :ref:`filters.hag`.

Introduction
-------------------------------------------------------------------------------

Normalized heights are a commonly used attribute of point cloud data. This can
also be referred to as *height above ground* (HAG) or *above ground level*
(AGL) heights. In the end, it is simply a measure of a point's relative height
as opposed to its raw elevation value.

The process of computing normalized heights is straightforward. First, we must
have an estimate of the underlying terrain model. With this we can compute the
difference between each point's elevation and the elevation of the terrain
model at the same XY coordinate. The quality of the normalized heights will be
a function of the quality of the terrain model, which of course depends on the
quality of the ground segmentation approach and any interpolation that is
required to arrive at the terrain elevation for a given XY coordinate.

We will use a nearest neighbor interpolation scheme to estimate terrain
elevations.

Approach
-------------------------------------------------------------------------------

In :ref:`filters.hag`, we only assume that our input point cloud has an already
existing ``Classification`` dimension with some subset of points marked as
ground (``Classification=2``). This could, for example, be generated by
:ref:`filters.pmf` or :ref:`filters.smrf` (see :ref:`pcl_ground`), but you can
use whichever method you choose, as long as the ground returns are marked.

.. note::

   We expect ground returns to have the classification value of 2 in keeping
   with the ASPRS Standard LIDAR Point Classes (see
   http://www.asprs.org/a/society/committees/standards/LAS_1_4_r13.pdf).

To compute the normalized heights, we first create a 2D KdTree (X and Y only) to
accelerate our nearest neighbor search. The tree is composed of only ground
returns. We then iterate over each of our points, searching for the nearest
neighbor in the ground points. We then compute the difference between the
elevation of the query point and the nearest neighbor in the ground set. This
value is encoded as a new dimension called ``HeightAboveGround``.

Example #1
-------------------------------------------------------------------------------

Using the autzen dataset (here shown colored by elevation)

.. image:: autzen-elevation.png
   :height: 400px

we run the following PDAL CLI command

::

    $ pdal translate autzen.laz autzen-height.bpf hag \
      --writers.bpf.output_dims="X,Y,Z,HeightAboveGround"

The result, when colored by the normalized height instead of elevation is

.. image:: autzen-height.png
   :height: 400px

Example #2
-------------------------------------------------------------------------------

If you'd like to overwrite your Z values, follow the height filter with :ref:`filters.ferry`.

::

    $ pdal translate input.laz output-height-as-Z.bpf hag ferry \
        --writers.bpf.output_dims="X,Y,Z" \
        --filters.ferry.dimensions="HeightAboveGround=Z"

Example #3
-------------------------------------------------------------------------------

If you don't yet have points classified as ground, start with :ref:`filters.pmf` or :ref:`filters.smrf`.

::

    $ pdal translate input.laz output-ground-height.bpf smrf hag \
          --writers.bpf.output_dims="X,Y,Z,HeightAboveGround"
